# Time Complexity Analysis

## What is Time Complexity?
- **Definition**: Time complexity measures how the running time of an algorithm changes as the size of the input (`n`) increases.
- It tells us **"how fast"** an algorithm grows with input size, not the exact seconds.
- Measured using **asymptotic notation** (e.g., Big O).

---

## Why Not Measure in Seconds?
- Execution time depends on:
  - Hardware speed (CPU, RAM)
  - Programming language
  - Compiler optimizations
- **Time complexity** gives a *machine-independent* way to compare algorithms.

---

## Order of Growth
- Describes **how the number of operations grows** relative to the input size.
- Common orders of growth:
  1. **O(1)** – Constant growth  
  2. **O(log n)** – Logarithmic growth  
  3. **O(n)** – Linear growth  
  4. **O(n log n)** – Linearithmic growth  
  5. **O(n²)** – Quadratic growth  
  6. **O(2ⁿ)** – Exponential growth  
  7. **O(n!)** – Factorial growth  
- Lower growth rate = better scalability for large inputs.

---


## Order of Growth – Comparison (Best to Worst Performance)

| Order of Growth | Name              | Example Algorithm / Use Case               | Performance Trend |
|-----------------|-------------------|---------------------------------------------|-------------------|
| **O(1)**        | Constant          | Accessing array element by index           | Best – Does not grow with input size |
| **O(log n)**    | Logarithmic       | Binary Search                               | Grows very slowly as input increases |
| **O(n)**        | Linear            | Linear Search, traversing an array         | Grows proportionally with input size |
| **O(n log n)**  | Linearithmic      | Merge Sort, Quick Sort (average case)       | Slightly worse than linear but efficient for large inputs |
| **O(n²)**       | Quadratic         | Bubble Sort, Insertion Sort                 | Slow for large inputs (nested loops) |
| **O(2ⁿ)**       | Exponential       | Solving Tower of Hanoi, brute-force on subsets | Becomes impractical very quickly |
| **O(n!)**       | Factorial         | Generating all permutations (brute-force)  | Worst – Grows explosively with input size |

---

### Key Takeaways
- **Best performers**: O(1), O(log n), O(n) – scalable for very large inputs.
- **Middle ground**: O(n log n) – optimal for most sorting algorithms.
- **Poor performers**: O(n²), O(2ⁿ), O(n!) – fine only for small input sizes.


## How to Analyze Time Complexity
1. **Identify Basic Operations**
   - The operation that affects runtime the most (e.g., comparisons, additions).
2. **Count How Many Times They Run**
   - Express as a function of `n` (input size).
3. **Find Growth Rate**
   - Focus on how it grows as `n` becomes very large.
   - Ignore constants and lower-order terms.

---


